# SUPPORT - SYMFONY : LES BASES

## OBJECTIFS

* Apprivoiser l'arborescence d'un projet Symfony;

* Apprendre √† se lancer dans le d√©veloppement d'un projet Symfony;

* Comprendre le fonctionnement du routing de Symfony avec la mise en place d'un contr√¥leur basique;

* Afficher des photos de chats, parce que les chats c'est trop meugnon üòΩ.

## INSTALLATION

* Premi√®rement, clone ce d√©p√¥t : https://github.com/WildCodeSchool/php-support-symfony-basics, qui est bas√© sur le *starter kit* √† partir duquel tu vas d√©marrer ton projet 3, qui a √©t√© pr√©par√© avec amour par ton/ta formateur¬∑ice ‚ù§Ô∏è.

* Ce repo, comme celui du Simple-MVC, contient un `composer.json` ainsi qu'un `composer.lock`, c'est donc qu'il y a potentiellement des d√©pendances PHP √† installer : lance `composer install` pour t√©l√©charger toutes tes d√©pendances PHP dans le dossier `/vendor`, alors automatiquement g√©n√©r√© par *Composer*.

* Tu te rends compte que ce repo poss√®de aussi un fichier `package.json`, ainsi qu'un `yarn.lock` : effectivement, au del√† des d√©pendances PHP, tu auras aussi besoin de d√©pendances Javascript pour certaines fonctionnalit√©s (comme la gestion des assets). Tu vas donc devoir utiliser *Yarn*, un gestionnaire de paquet sp√©cifique aux d√©pendances JS, et lancer `yarn install`. De la m√™me mani√®re que les d√©pendances install√©es via *Composer* sont t√©l√©charg√©es dans `/vendor`, celles install√©es via *Yarn* sont t√©l√©charg√©es dans le dossier `/node_modules`.

* Ensuite, lance `yarn encore dev`. Cette commande va lancer **Webpack-Encore**, l'une des d√©pendances JS que tu as install√©es, qui va cr√©√©r un *build* de tes assets (nous allons revoir √ßa un peu plus loin).

* Enfin, tu dois configuer tes informations de connexion √† ta base de donn√©es : avec Symfony, en phase de d√©veloppement, cela ce fait dans un fichier `.env.local` (**non versionn√© ‚ùó**), que tu dois cr√©√©r toi m√™me en copiant le fichier `.env` √† la racine du projet, et configurer la ligne commen√ßant par `DATABASE_URL="mysql://`.

Et voil√†, tu devrais √™tre pr√™t¬∑e √† travailler sur ton projet Symfony! Plus qu'√† lancer `symfony serve` √† la racine de ton projet pour lancer ton serveur (c'est un peu comme un `php -S localhost:8000 -t public`, mais avec des outils en plus), et √† te rendre √† `localhost:8000` dans ton navigateur, pour y voir un magnifique GIF anim√© sur fond de couleur rose-wild üôÇ.

## L'ARCHITECTURE

Un projet Symfony basique utilise une architecture de type MVC. Pas de grande surprise donc, les principes g√©n√©raux sont les m√™mes que pour le Simple-MVC. Faisons un tour rapide des dossiers qui nous int√©ressent aujourd'hui :

### /public

Ici, m√™me principe que pour le Simple-MVC : ce dossier va principalement contenir ton fichier index.php, seule porte d'entr√©e de ton application. Tu peux aussi observer un dossier `/build` non versionn√©, mais nous verrons √ßa juste un peu plus loin üòâ.

### /src

On retrouve un dossier `/src`, contenant la logique de ton application. Dedans, on trouve un dossier `/Controller` dans lequel tu rangeras tes **contr√¥leurs** (en toute logique). Petite nuance : les m√©thodes de ces **contr√¥leurs** devront toujours renvoyer un objet de la classe Symfony `Response`, qui repr√©sente une r√©ponse HTTP compl√®te, ce qui peut contenir entre autres un document HTML.

Comme pour le Simple-MVC, chaque *m√©thode* d'une classe de **contr√¥leur** est li√©e √† une *route*. Seulement ici, plus besoin de se casser la t√™te avec des histoires de nom de la classe suivie du nom de la m√©thode auquel on aditionne le nombre moyen de dents d'une girafe ! En effet, tu es ici compl√®tement ma√Ætre¬∑sse de la t√™te qu'auront tes routes, en utilisant l'annotation `@Route`. Nous n'allons pas nous attarder maintenant sur cette notion, c'est plus parlant avec des exemples üòâ.

On trouve aussi un dossier `/Entity` et un dossier `/Repository`, qui, √† eux deux, repr√©sentent ton **mod√®le**, mais nous reviendrons sur ces notions lors d'un autre groupe de support.

Tu peux aussi voir un dossier `/DataFixtures`, mais ce dossier l√† aussi sera abord√© une autre fois üòâ.

### /templates

Petite variation par rapport au Simple-MVC, les **vues** sont rang√©es hors du dossier `/src`, dans un dossier √† part nomm√© `/templates` (notez bien : template**S**, au pluriel üòâ).

√Ä part √ßa, pas de surprise majeure pour les vues : c'est du *Twig* comme tu en as d√©j√† utilis√© pour ton projet 2 üôÇ.

### /assets

Tu as d√ª remarquer ce dossier `/assets` tout l√† haut, bien loin du dossier `/public` o√π tu as l'habitude de le voir! Non, il ne boude pas, il est bien l√† pour une vraie raison.

En effet, **Webpack-Encore** te permet de cr√©er automatiquement des *builds* utilisables √† partir des *assets* que tu vas ranger dans le dossier `/assets`, et ce sont ces *builds* que tu pourras retrouver dans `/public/build`.

Exemple : pour des raisons d'efficacit√© et de lisibilit√© de ton code, tu d√©cides de coder tout ton style en *scss*. Seulement, les navigateurs ne pouvant lire le *scss*, il faut faire passer ce dernier par une √©tape de *compilation* en *css* pour obtenir une feuille de style utilisable par ton navigateur. C'est ici qu'intervient **Encore**, en te proposant par exemple de compiler ton *scss* en *css*, soit √† chaque fois que tu lui demandes en lan√ßant `yarn encore dev` (comme tu l'as fait durant l'√©tape d'installation), ou m√™me automatiquement √† chaque fois que tu modifies un fichier situ√© dans `/assets` en lan√ßant `yarn encore dev --watch`.

Mais ce n'est pas tout : **Encore** peut aussi faire d'autres choses, comme *minifier tes assets* pour l'environemment de production, *etc*...

## √Ä TOI DE JOUER !

C'est pas tout √ßa de bavarder, mais il serait temps d'essayer un peu tout √ßa! Commen√ßons donc par... tout casser! En effet, le *starter kit* concoct√© par tes formateur¬∑ice¬∑s d'amour contient d√©j√† un fichier `src/Controller/HomeController.php` (supprime le), ainsi que le dossier `/templates/home` qui y est associ√© (supprime le aussi üôÉ). Enfin, tu peux supprimer le style pr√©configur√© pour le `body` dans le fichier `assets/styles/app.scss`, mais n'oublie pas de relancer `yarn encore dev` pour relancer un _build_ et que tes modifications de style soient prises en compte!

Une fois que c'est fait, nous allons pouvoir nous lancer dans une t√¢che des plus importantes! Nous allons cr√©er des pages qui affichent des photos de leurs Majest√©es Velues, Seigneurs du Web et Souverains des R√©seaux : les Chats üêà.

### "TON AMI C'EST MOI, TU SAIS, JE SUIS TON AMI" - LE BINAIRE SYMFONY

*"Feurst fingz feurst"*, comme disent nos camarades d'Outre-Manche : lorsque l'on veut que notre application affiche une page web, on commence par mettre en place la route qui est associ√©e √† cette page, et donc le contr√¥leur qui va bien.

Et c'est l√† que tu vas commencer √† go√ªter √† toute la puissance de ton nouveau meilleur ami : le **Binaire Symfony** ü§Ø. En effet, √† partir de maintenant, ce dernier va te permettre de faire un certain nombre d'actions - comme g√©n√©rer des fichiers ou des bouts de code automatiquement (mais pas que üòâ) - ce qui te fera gagner un temps consid√©rable!

Essaie donc d'utiliser le *maker bundle* en lan√ßant la commande `bin/console make:controller`. On ne te demande alors qu'une chose : de donner un nom √† ta classe de **contr√¥leur**. Appelons-la juste *"Cat"*.

Une fois cette unique √©tape pass√©e, tu remarques plusieurs choses :

* Un fichier `CatController.php` a √©t√© g√©n√©r√© dans ton dossier `src/Controller`, contenant la d√©finition d'une classe de contr√¥leur basique nomm√©e `CatController`, sans que tu aies eu besoin de pr√©ciser *"Controller"* lorsque l'on t'a demand√© de nommer ta classe;

* Tous les `use` fondammentaux dont une classe de **contr√¥leur** Symfony a besoin sont d√©j√† l√†, ainsi que le `extends` qui va bien;

* Une m√©thode `index()` simple a √©t√© g√©n√©r√©e √† titre d'exemple, qui renvoie bien un objet de la classe `Response`, (ce qui inclut ici entre autres la vue twig `/templates/cat/index.html.twig` compil√©e en HTML, comme pour le Simple-MVC);

* Cette derni√®re m√©thode poss√®de une annotation `@Route`, qui d√©finit la route associ√©e √† cette m√©thode √† `/cat`, et la nomme `cat`;

* Un dossier `/cat` a √©t√© g√©n√©r√© dans `/templates`, contenant une vue `index.html.twig` ici aussi √† titre d'exemple.

Bref, pas mal de choses se sont pass√©es, essayons d'ammadouer tout √ßa!

### HELLO, KITTY !

Commen√ßons une fois de plus, et en l'honneur de nos adorables (et v√©n√©rables) Chefs Supr√™mes... par tout casser üôÉ.
<!--- {% raw %} --->
Vide donc les `{% block body %}` et `{% block title %}` de leur contenu g√©n√©r√© automatiquement dans ton fichier `cat/index.html.twig`. Dans la m√©thode `index()` de ton `CatController`, supprime aussi l'envoi du nom du contr√¥leur dans ta vue.

Une fois que tu as fais √ßa, ajoute un `<h1>` contenant le titre de ton choix √† ta vue dans ton `{% block body %}`, ainsi qu'un `<p>`, par exemple, contenant `Cat #{{ id }}`.

Essaie donc ensuite d'injecter une variable `id` (un nombre en dur) dans ta vue depuis ton contr√¥leur. Pas de surprise ici, c'est du Twig comme tu en as d√©j√† vu. En te rendant √† `localhost:8000/cat` tu devrais donc voir `Cat #4` lorsque tu envoies le nombre *4* en id √† ta vue.

Maintenant, passons aux choses s√©rieuses.

Placekitten est une phototh√®que permettant de r√©cup√©rer des photos de chats et chatons trop meugnons üê±. Elle contient 16 photos. Remplace donc ton `<p>` par `<img src="https://placekitten.com/400/500?image={{ id }}" alt="a cute cat">`. Si l'`id` que tu envoies √† ta vue est bien un nombre entier entre 1 et 16, tu devrais d√©sormais voir une magnifique photo de chat! Essaie de changer l'`id` que tu envoies depuis ton contr√¥leur, la photo devrait changer üôÇ.

### "ET J'√âTAIS SUR LA ROUTE TOUTE LA SAINTE JOURN√âE" - TOI

On peut r√©cup√©rer nos photos de chats, cela dit on aimerait bien laisser √† l'utilisateur le choix de la photo qu'il veut voir. Rien de plus simple avec Symfony, il suffit de passer notre `id` en param√®tre de notre contr√¥leur, et de modifier son annotation `@Route`, pour r√©cup√©rer l'`id` demand√© par l'utilisateur.

Une fois modifi√©, ton contr√¥leur devrait ressembler √† √ßa :

```php
/**
 * @Route("/cat/{id}", name="cat")
 */
public function index(int $id): Response
{
    return $this->render('cat/index.html.twig', [
        'id' => $id,
    ]);
}
```

Et c'est tout üôÇ. Cela dit, attention, ta route `/cat` n'est d√©sormais plus valide! En effet, √† partir de maintenant, si tu veux afficher une photo de chat, il faut que tu ailles √† la route `/cat/{id}`, en rempla√ßant `{id}` par un nombre entre 1 et 16. Essaie d'aller √† `/cat/3` par exemple, tu devrais voir une photo de chat tigr√© dans la neige, et √† `/cat/11`, tu devrais avoir un chaton blanc trop mignon üôÉ. C'est bien que cet `id` est r√©cup√©r√© automatiquement dans ta route par le routeur Symfony via l'annotation `@Route`, et est ensuite utilisable dans ton contr√¥leur en lui passant `$id` en param√®tre. Le routeur Symfony est intelligent, il fait directement le lien entre l'`id` de l'annotation `@Route` et `$id`, le param√®tre de ta m√©thode `index` üôÇ.

On est pas mal, mais on aimerait quand m√™me pouvoir naviguer autrement que via la barre d'adresse. Nous pourrions par exemple ajouter des liens "photo suivante" et "photo pr√©c√©dente" √† notre page üôÇ.

Par contre attention, avec Symfony, on n'√©crit plus les routes en dur dans l'attribut `href` de nos liens : on va pr√©f√©rer utiliser une *fonction Twig* nomm√©e `path()`. Cette fonction prend en premier param√®re le *nom* d'une route (celui configur√© dans l'annotation `@Route` üòâ), et peut prendre un deuxi√®me param√®tre sous la forme d'un *tableau Twig* contenant les valeurs que l'on va passer en argument de notre contr√¥leur. Exemple :

```twig
<a href="{{ path('nom_de_la_route', {param1: valeur1, param2: valeur2}) }}">Un lien</a>
```
Ici, pour nos deux liens, le nom de la route devrait √™tre *"cat"*, et nous n'avons qu'un seul param√®tre - `id` - qui devrait √™tre √©gal dans un cas √† l'`id` actuel plus un, et dans l'autre √† l'`id` actuel moins un. Au boulot!

Mais pourquoi s'emb√™ter √† donner des noms √† nos routes? Et bien essayons quelque chose : imaginons que nous voulions modifier la route que nous avons cr√©√©e. Dans l'annotation `@Route` de ta m√©thode `index()`, remplace `/cat/{id}` par `/cute-cat/{id}`. Rends toi ensuite dans ton navigateur √† `localhost:8000/cute-cat/11` par exemple, et essaie d'utiliser tes liens "pr√©c√©dent" et "suivant". Surprise, ils marchent toujours! M√™me si la route a chang√©, tu n'as pas eu besoin de modifier tes liens pour qu'ils fonctionnent car le *nom de la route* est, lui, rest√© le m√™me üôÇ.

Tes boutons "pr√©c√©dent" et "suivant" sont bien beaux, mais tu aimerais pouvoir donner √† ton utilisateur la possibilit√© de sauter d'une image √† une autre sans devoir parcourir toute la photot√®que de placekitten. Maintenant que tu sais cr√©er des liens avec Symfony, √† toi de cr√©er tous ces liens sous la forme que tu veux üôÇ (une navbar √† inclure dans base.html.twig avec une boucle twig allant de 1 √† 16 par exemple? üòâ).
<!--- {% endraw %} --->
## CONCLUSION

Voil√† qui clos ce premier support sur les bases de Symfony, on se retrouve peut √™tre pour le suivant, dans lequel on va parler bases de donn√©es avec Doctrine!
